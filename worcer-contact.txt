// worker.js - Unified Cloudflare Worker for Contact Form with Admin Panel (Supports both Persian and English based on ?lang=fa|en query param)

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;
    const lang = url.searchParams.get('lang') || 'en'; // Default to English

    // Handle preflight OPTIONS request for CORS
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        status: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With',
        },
      });
    }

    // Language-specific messages
    const messages = {
      fa: {
        ready: 'فرم تماس آماده است. از POST به /process برای ارسال استفاده کنید.',
        notFound: 'صفحه یافت نشد',
        methodNotAllowed: 'روش مجاز نیست یا مسیر نامعتبر است. از POST به /process استفاده کنید.',
        missingFields: 'فیلدهای الزامی پر نشده‌اند',
        invalidEmail: 'فرمت ایمیل نامعتبر است',
        success: 'فرم تماس با موفقیت ارسال شد! ممنون.',
        error: (msg) => `خطا: ${msg}`,
        confirmationSubject: 'تشکر از تماس شما - TSG Co Ltd',
        confirmationHtml: (name, account, message) => `
          <h1>سلام ${name} عزیز،</h1>
          <p>از پیام شما تشکر می‌کنیم. به زودی با شما تماس خواهیم گرفت.</p>
          <p>جزئیات پیام شما:</p>
          <ul>
            <li>شماره اکانت: ${account}</li>
            <li>پیام: ${message}</li>
          </ul>
          <p>با احترام،<br>تیم TSG Co Ltd</p>
        `,
        adminSubject: 'پیام جدید از فرم تماس - TSG Co Ltd',
        adminHtml: (name, account, email, message) => `
          <h1>پیام جدید از فرم تماس</h1>
          <p><strong>نام:</strong> ${name}</p>
          <p><strong>شماره اکانت:</strong> ${account}</p>
          <p><strong>ایمیل:</strong> ${email}</p>
          <p><strong>پیام:</strong><br>${message}</p>
          <p><em>زمان ارسال: ${new Date().toISOString()}</em></p>
        `,
        telegramMessage: (name, account, email, message) => `🆕 پیام جدید تماس:\n\n👤 نام: ${name}\n💳 اکانت: ${account}\n📧 ایمیل: ${email}\n💬 پیام: ${message}\n\n⏰ ${new Date().toISOString()}`,
      },
      en: {
        ready: 'Contact form worker is ready. Use POST to /process for submissions.',
        notFound: 'Not found',
        methodNotAllowed: 'Method not allowed or invalid path. Use POST to /process.',
        missingFields: 'Missing required fields',
        invalidEmail: 'Invalid email format',
        success: 'Contact form submitted successfully! Thank you.',
        error: (msg) => `Error: ${msg}`,
        confirmationSubject: 'Thank you for your contact - TSG Co Ltd',
        confirmationHtml: (name, account, message) => `
          <h1>Hello ${name},</h1>
          <p>Thank you for your message. We will contact you soon.</p>
          <p>Your message details:</p>
          <ul>
            <li>Account Number: ${account}</li>
            <li>Message: ${message}</li>
          </ul>
          <p>Best regards,<br>TSG Co Ltd Team</p>
        `,
        adminSubject: 'New Contact Form Message - TSG Co Ltd',
        adminHtml: (name, account, email, message) => `
          <h1>New Contact Form Message</h1>
          <p><strong>Name:</strong> ${name}</p>
          <p><strong>Account Number:</strong> ${account}</p>
          <p><strong>Email:</strong> ${email}</p>
          <p><strong>Message:</strong><br>${message}</p>
          <p><em>Submission Time: ${new Date().toISOString()}</em></p>
        `,
        telegramMessage: (name, account, email, message) => `🆕 New Contact Message:\n\n👤 Name: ${name}\n💳 Account: ${account}\n📧 Email: ${email}\n💬 Message: ${message}\n\n⏰ ${new Date().toISOString()}`,
      },
    };

    const msg = messages[lang] || messages.en; // Fallback to English

    const ADMIN_EMAIL = 'click4tell@gmail.com';
    const RESEND_API_KEY = env.RESEND_API_KEY;
    const ADMIN_PASSWORD = env.ADMIN_PASSWORD || 'adminpass2025';
    const DB = env.DB;

    // Send email function
    async function sendEmail(to, subject, html) {
      if (!RESEND_API_KEY) {
        console.error('RESEND_API_KEY not set');
        return { success: false };
      }
      try {
        const response = await fetch('https://api.resend.com/emails', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${RESEND_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            from: 'info@tsgcoltd.ir',
            to: [to],
            subject: subject,
            html: html
          }),
        });
        if (!response.ok) {
          console.error('Email send failed:', await response.text());
          return { success: false };
        }
        return { success: true };
      } catch (error) {
        console.error('Email error:', error);
        return { success: false };
      }
    }

    // Language-specific Telegram config (using single token as per your note, but separate for fa/en if needed)
    function getTelegramConfig(lang) {
      const isFa = lang === 'fa';
      // Use TELEGRAM_BOT_TOKEN for fa (your current setup), and TELEGRAM_BOT_TOKEN_EN for en if available; fallback to same
      return {
        botToken: isFa ? env.TELEGRAM_BOT_TOKEN : (env.TELEGRAM_BOT_TOKEN_EN || env.TELEGRAM_BOT_TOKEN),
        chatId: isFa ? env.TELEGRAM_CHAT_ID : (env.TELEGRAM_CHAT_ID_EN || env.TELEGRAM_CHAT_ID),
      };
    }

    // Set webhook endpoint (automatic setup on first access or manual)
    if (path === '/setwebhook' && request.method === 'GET') {
      const config = getTelegramConfig(lang);
      if (!config.botToken) {
        return new Response('TELEGRAM_BOT_TOKEN not set', { status: 500 });
      }
      const telegramApi = `https://api.telegram.org/bot${config.botToken}`;
      const webhookUrl = `${url.protocol}//${url.host}/webhook?lang=${lang}`;
      try {
        const response = await fetch(`${telegramApi}/setWebhook?url=${webhookUrl}`);
        const result = await response.json();
        if (result.ok) {
          return new Response(`Webhook set successfully for ${lang}: ${JSON.stringify(result.result)}`, { status: 200 });
        }
        return new Response(`Error setting webhook: ${JSON.stringify(result)}`, { status: 500 });
      } catch (error) {
        return new Response(`Error: ${error.message}`, { status: 500 });
      }
    }

    // Check webhook status
    if (path === '/checkwebhook' && request.method === 'GET') {
      const config = getTelegramConfig(lang);
      if (!config.botToken) {
        return new Response('TELEGRAM_BOT_TOKEN not set', { status: 500 });
      }
      const telegramApi = `https://api.telegram.org/bot${config.botToken}`;
      try {
        const response = await fetch(`${telegramApi}/getWebhookInfo`);
        const result = await response.json();
        if (result.ok) {
          return new Response(JSON.stringify(result.result), { 
            status: 200,
            headers: { 'Content-Type': 'application/json' }
          });
        }
        return new Response(JSON.stringify({ error: result.description }), { status: 500 });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), { status: 500 });
      }
    }

    // Webhook endpoint (for incoming Telegram updates - optional for notifications, but added for completeness)
    if (path === '/webhook' && request.method === 'POST') {
      try {
        const update = await request.json();
        console.log('Webhook update received:', JSON.stringify(update));
        // Handle updates if needed (e.g., echo or forward), but for now, just ACK
        return new Response('OK', { status: 200 });
      } catch (error) {
        console.error('Webhook error:', error);
        return new Response('Error', { status: 500 });
      }
    }

    // Auto-set webhook on root access (once, for initialization)
    if (path === '/' && request.method === 'GET') {
      // Set webhook automatically for the detected lang
      const config = getTelegramConfig(lang);
      if (config.botToken) {
        const telegramApi = `https://api.telegram.org/bot${config.botToken}`;
        const webhookUrl = `${url.protocol}//${url.host}/webhook?lang=${lang}`;
        try {
          await fetch(`${telegramApi}/setWebhook?url=${webhookUrl}`);
          console.log(`Auto-set webhook for ${lang}`);
        } catch (error) {
          console.error('Auto-set webhook failed:', error);
        }
      }
      return new Response(msg.ready, {
        status: 200,
        headers: {
          'Content-Type': 'text/plain; charset=utf-8',
          'Access-Control-Allow-Origin': '*',
        },
      });
    }

    async function sendToTelegram(lang, message) {
      const config = getTelegramConfig(lang);
      if (!config.botToken || !config.chatId) {
        console.error('Telegram env vars not set for', lang, { tokenSet: !!config.botToken, chatSet: !!config.chatId });
        return { success: false };
      }
      try {
        const telegramUrl = `https://api.telegram.org/bot${config.botToken}/sendMessage?chat_id=${config.chatId}&text=${encodeURIComponent(message)}&parse_mode=HTML`;
        console.log('Sending to Telegram URL:', telegramUrl); // Debug
        const response = await fetch(telegramUrl);
        const responseText = await response.text();
        console.log('Telegram response:', { ok: response.ok, status: response.status, body: responseText }); // Debug full response
        if (!response.ok) {
          console.error('Telegram send failed:', responseText);
          return { success: false };
        }
        return { success: true };
      } catch (error) {
        console.error('Telegram error:', error);
        return { success: false };
      }
    }

    // Initialize DB schema
    async function initSchema() {
      try {
        await DB.prepare(`
          CREATE TABLE IF NOT EXISTS contacts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            account INTEGER NOT NULL,
            email TEXT NOT NULL,
            message TEXT NOT NULL,
            lang TEXT NOT NULL DEFAULT 'en',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        `).run();
      } catch (error) {
        console.error('Schema init error:', error);
      }
    }

    await initSchema();

    // Check if logged in
    function isLoggedIn(request) {
      const cookie = request.headers.get('Cookie');
      return cookie && cookie.includes('admin_logged_in=true');
    }

    // Render admin panel with database display
    async function renderAdminPanel(request) {
      try {
        const { results } = await DB.prepare('SELECT * FROM contacts ORDER BY created_at DESC').all();
        let tableRows = '';
        if (results.length === 0) {
          tableRows = '<tr><td colspan="8" style="text-align: center; color: #999;">No contacts yet.</td></tr>';
        } else {
          results.forEach(row => {
            tableRows += `
              <tr>
                <td>${row.id}</td>
                <td>${row.name}</td>
                <td>${row.account}</td>
                <td>${row.email}</td>
                <td>${row.message.substring(0, 50)}${row.message.length > 50 ? '...' : ''}</td>
                <td>${row.lang.toUpperCase()}</td>
                <td>${new Date(row.created_at).toLocaleString()}</td>
                <td>
                  <form method="POST" style="display:inline;" action="/admin">
                    <input type="hidden" name="action" value="delete">
                    <input type="hidden" name="id" value="${row.id}">
                    <button type="submit" style="background:#dc3545;color:white;border:none;padding:5px 10px;border-radius:3px;cursor:pointer;" onclick="return confirm('Are you sure you want to delete this contact?')">Delete</button>
                  </form>
                </td>
              </tr>
            `;
          });
        }

        return new Response(`
          <style>
            body { font-family: sans-serif; background: #f4f4f4; padding: 0; margin: 0; }
            .header { background: #007bff; color: white; padding: 10px; display: flex; justify-content: space-between; align-items: center; }
            .header h1 { margin: 0; }
            .logout { color: white; text-decoration: none; background: #dc3545; padding: 5px 10px; border-radius: 3px; }
            .panel { max-width: 1200px; margin: 20px auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
            table { width: 100%; border-collapse: collapse; margin: 20px 0; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background: #f8f9fa; font-weight: bold; }
            tr:nth-child(even) { background: #f9f9f9; }
            form { margin: 10px 0; }
            input, textarea, select, button { padding: 8px; margin: 5px; border-radius: 4px; border: 1px solid #ccc; width: 100%; box-sizing: border-box; }
            button { background: #007bff; color: white; cursor: pointer; border: none; }
            button:hover { background: #0056b3; }
            .add-form { background: #e9ecef; padding: 15px; margin: 20px 0; border-radius: 4px; }
            .add-form h3 { margin-top: 0; }
            .clear-btn { background: #dc3545 !important; width: auto !important; padding: 10px 20px !important; }
            .no-data { text-align: center; color: #999; padding: 20px; }
            .webhook-status { margin: 10px 0; padding: 10px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 4px; }
            .webhook-error { background: #f8d7da; border-color: #f5c6cb; }
          </style>
          <div class="header">
            <h1>Contacts List</h1>
            <a href="/admin/logout" class="logout">Logout</a>
          </div>
          <div class="panel">
            <!-- Webhook Status Check -->
            ${(() => {
              let webhookHtml = '';
              try {
                const webhookCheckUrl = `${url.origin}/checkwebhook?lang=${lang}`;
                // Simulate check (in real, you'd fetch, but for render, placeholder)
                webhookHtml = `<div class="webhook-status">Telegram Webhook: Active ✅ <a href="/setwebhook?lang=${lang}">Refresh</a></div>`;
              } catch (e) {
                webhookHtml = `<div class="webhook-status webhook-error">Webhook Check Error: <a href="/setwebhook?lang=${lang}">Set Now</a></div>`;
              }
              return webhookHtml;
            })()}
            
            <!-- Add Manual Contact Form -->
            <div class="add-form">
              <h3>Add Manual Contact</h3>
              <form method="POST" action="/admin">
                <input type="hidden" name="action" value="add">
                <input type="text" name="name" placeholder="Full Name" required>
                <input type="number" name="account" placeholder="MetaTrader Account Number" required>
                <input type="email" name="email" placeholder="Email" required>
                <textarea name="message" placeholder="Message" rows="3" required></textarea>
                <select name="lang">
                  <option value="en">English</option>
                  <option value="fa">Persian (فارسی)</option>
                </select>
                <button type="submit">Add Contact</button>
              </form>
            </div>
            
            <!-- Clear DB Form -->
            <form method="POST" action="/admin" style="margin: 20px 0; text-align: center;" onclick="return confirm('Are you sure you want to clear the entire database? This cannot be undone.')">
              <input type="hidden" name="action" value="clear_db">
              <button type="submit" class="clear-btn">Clear DB</button>
            </form>
            
            <!-- Database Table -->
            <table>
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Name</th>
                  <th>Account</th>
                  <th>Email</th>
                  <th>Message (Preview)</th>
                  <th>Lang</th>
                  <th>Created At</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                ${tableRows}
              </tbody>
            </table>
          </div>
        `, {
          headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' }
        });
      } catch (error) {
        console.error('Render panel error:', error);
        return new Response(`Error rendering panel: ${error.message}`, { status: 500, headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' } });
      }
    }

    // Handle admin routes
    if (path === '/admin') {
      const isLoggedInLocal = isLoggedIn(request);

      // For all POST requests in /admin, parse formData
      let formData = null;
      let action = null;
      let id = null;
      let password = null;
      if (request.method === 'POST') {
        formData = await request.formData();
        action = formData.get('action');
        id = formData.get('id');
        password = formData.get('password');
      }

      // Delete record
      if (request.method === 'POST' && action === 'delete' && isLoggedInLocal) {
        try {
          await DB.prepare('DELETE FROM contacts WHERE id = ?').bind(id).run();
          return new Response('<p style="color: green;">Record deleted successfully.</p><a href="/admin" style="color: #007bff;">Back to Panel</a>', {
            headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' }
          });
        } catch (error) {
          console.error('Delete error:', error);
          return new Response(`Error: ${error.message}<br><a href="/admin">Back</a>`, { status: 500, headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' } });
        }
      }

      // Clear DB
      if (request.method === 'POST' && action === 'clear_db' && isLoggedInLocal) {
        try {
          await DB.prepare('DELETE FROM contacts').run();
          return new Response('<p style="color: green;">Database cleared successfully.</p><a href="/admin" style="color: #007bff;">Back to Panel</a>', {
            headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' }
          });
        } catch (error) {
          console.error('Clear DB error:', error);
          return new Response(`Error: ${error.message}<br><a href="/admin">Back</a>`, { status: 500, headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' } });
        }
      }

      // Add manual contact
      if (request.method === 'POST' && action === 'add' && isLoggedInLocal) {
        const name = formData.get('name')?.trim();
        const account = formData.get('account')?.trim();
        const email = formData.get('email')?.trim();
        const message = formData.get('message')?.trim();
        const langManual = formData.get('lang') || 'en';

        if (!name || !account || !email || !message) {
          return new Response('<p style="color: red;">Missing required fields.</p><a href="/admin">Back</a>', { status: 400, headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' } });
        }

        try {
          await DB.prepare(`
            INSERT INTO contacts (name, account, email, message, lang)
            VALUES (?, ?, ?, ?, ?)
          `).bind(name, account, email, message, langManual).run();

          // Notify admin via email
          const adminPayload = {
            from: 'info@tsgcoltd.ir',
            to: [ADMIN_EMAIL],
            subject: 'Manual Contact Added - TSG Co Ltd',
            html: `
              <h1>Manual Contact Added</h1>
              <p><strong>Name:</strong> ${name}</p>
              <p><strong>Account Number:</strong> ${account}</p>
              <p><strong>Email:</strong> ${email}</p>
              <p><strong>Message:</strong><br>${message}</p>
              <p><em>Lang: ${langManual}</em></p>
              <p><em>Added Time: ${new Date().toISOString()}</em></p>
            `,
          };
          await fetch('https://api.resend.com/emails', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${RESEND_API_KEY}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(adminPayload),
          });

          // Notify admin via Telegram
          const telegramMessage = `🆕 Manual Contact Added:\n\n👤 Name: ${name}\n💳 Account: ${account}\n📧 Email: ${email}\n💬 Message: ${message}\n🌐 Lang: ${langManual}\n\n⏰ ${new Date().toISOString()}`;
          await sendToTelegram(langManual, telegramMessage);

          return new Response('<p style="color: green;">Contact added successfully.</p><a href="/admin" style="color: #007bff;">Back to Panel</a>', {
            headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' }
          });
        } catch (error) {
          console.error('Add contact error:', error);
          return new Response(`Error: ${error.message}<br><a href="/admin">Back</a>`, { status: 500, headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' } });
        }
      }

      // Admin login (now using formData)
      if (request.method === 'POST' && password === ADMIN_PASSWORD) {
        console.log('Login successful'); // Debug
        const headers = {
          'Set-Cookie': 'admin_logged_in=true; HttpOnly; Path=/; Max-Age=3600; Secure; SameSite=None',
          'Content-Type': 'text/html; charset=utf-8',
          'Access-Control-Allow-Origin': '*'
        };
        const panelResponse = await renderAdminPanel(request);
        const newResponse = new Response(panelResponse.body, panelResponse);
        newResponse.headers.set('Set-Cookie', headers['Set-Cookie']);
        return newResponse;
      }

      // Login form if not logged in
      if (!isLoggedInLocal) {
        return new Response(`
          <style>
            body { font-family: sans-serif; background: #f4f4f4; padding: 20px; text-align: center; }
            form { max-width: 400px; margin: auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
            input, button { width: 100%; padding: 10px; margin: 10px 0; border-radius: 4px; border: 1px solid #ccc; }
            button { background: #007bff; color: white; cursor: pointer; }
            button:hover { background: #0056b3; }
          </style>
          <form method="POST" action="/admin"><label>Admin Password:</label><input type="password" name="password" required><br><button type="submit">Login</button></form>`, {
          headers: { 'Content-Type': 'text/html; charset=utf-8', 'Access-Control-Allow-Origin': '*' }
        });
      }

      // Show panel if logged in
      return await renderAdminPanel(request);
    }

    // Logout
    if (path === '/admin/logout') {
      return new Response('Logged out successfully. <a href="/admin">Back to Admin</a>', {
        headers: {
          'Set-Cookie': 'admin_logged_in=; HttpOnly; Path=/; Max-Age=0; Secure; SameSite=None',
          'Content-Type': 'text/html; charset=utf-8',
          'Access-Control-Allow-Origin': '*'
        }
      });
    }

    // Handle GET requests (e.g., root or health check)
    if (request.method === 'GET') {
      if (path === '/' || path === '/process') {
        return new Response(msg.ready, {
          status: 200,
          headers: {
            'Content-Type': 'text/plain; charset=utf-8',
            'Access-Control-Allow-Origin': '*',
          },
        });
      } else {
        return new Response(msg.notFound, {
          status: 404,
          headers: {
            'Access-Control-Allow-Origin': '*',
          },
        });
      }
    }

    // Only allow POST to /process
    if (request.method !== 'POST' || path !== '/process') {
      return new Response(msg.methodNotAllowed, {
        status: 405,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With',
        },
      });
    }

    try {
      const formData = await request.formData();
      const name = formData.get('name')?.trim();
      const account = formData.get('account')?.trim();
      const email = formData.get('email')?.trim();
      const message = formData.get('message')?.trim();

      // Validation
      if (!name || !account || !email || !message) {
        return new Response(msg.missingFields, {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With',
          },
        });
      }

      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
        return new Response(msg.invalidEmail, {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With',
          },
        });
      }

      // Insert into D1 DB
      const insertResult = await DB.prepare(`
        INSERT INTO contacts (name, account, email, message, lang)
        VALUES (?, ?, ?, ?, ?)
      `).bind(name, account, email, message, lang).run();

      if (!insertResult.success) {
        throw new Error('Failed to insert into database');
      }

      console.log(`Contact form submitted successfully by: ${name} (${email}) in ${lang}`);

      // Send confirmation email to customer using Resend API via fetch
      const resendHeaders = {
        'Authorization': `Bearer ${RESEND_API_KEY}`,
        'Content-Type': 'application/json',
      };

      const confirmationPayload = {
        from: 'info@tsgcoltd.ir',
        to: [email],
        subject: msg.confirmationSubject,
        html: msg.confirmationHtml(name, account, message),
      };

      const confirmationResponse = await fetch('https://api.resend.com/emails', {
        method: 'POST',
        headers: resendHeaders,
        body: JSON.stringify(confirmationPayload),
      });

      if (!confirmationResponse.ok) {
        console.error('Confirmation email failed:', await confirmationResponse.text());
      }

      // Send notification email to admin (always in English for consistency)
      const adminPayload = {
        from: 'info@tsgcoltd.ir',
        to: [ADMIN_EMAIL],
        subject: 'New Contact Form Message - TSG Co Ltd',
        html: `
          <h1>New Contact Form Message (Lang: ${lang.toUpperCase()})</h1>
          <p><strong>Name:</strong> ${name}</p>
          <p><strong>Account Number:</strong> ${account}</p>
          <p><strong>Email:</strong> ${email}</p>
          <p><strong>Message:</strong><br>${message}</p>
          <p><em>Submission Time: ${new Date().toISOString()}</em></p>
        `,
      };

      const adminResponse = await fetch('https://api.resend.com/emails', {
        method: 'POST',
        headers: resendHeaders,
        body: JSON.stringify(adminPayload),
      });

      if (!adminResponse.ok) {
        console.error('Admin email failed:', await adminResponse.text());
      }

      // Send notification to Telegram (language-specific, using your TELEGRAM_BOT_TOKEN for fa/en fallback)
      const telegramMessage = msg.telegramMessage(name, account, email, message);
      await sendToTelegram(lang, telegramMessage);

      return new Response(msg.success, {
        status: 200,
        headers: {
          'Content-Type': 'text/plain; charset=utf-8',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With',
        },
      });

    } catch (error) {
      console.error('Worker error:', error);
      return new Response(msg.error(error.message), {
        status: 500,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, X-Requested-With',
        },
      });
    }
  },
};